# chapter12

## 类中动态内存

如果在类中使用new和delete运算符动态控制内存，析构函数**必不可少**，可能还需要重载赋值运算符

在构造函数中使用new来分配内存时，**必须**在相应的析构函数中使用delete来释放内存

### 静态类成员

静态类成员有一个特点：无论创建了多少对象，程序**只**创建一个静态类变量副本，也就是所有的对象使用同一个值

静态类成员不在类声明中初始化，并且它也不是在构造函数内初始化，**单独初始化**，初始化时也不带有static关键字；但如果静态成员是const整数类型或枚举型，则可以在类声明初始化

带参数的构造函数**也可以**是默认构造函数，只要所有参数都有默认值；也就是说可以只定义一个带有默认值参数的构造函数，但只能存在一个默认的构造函数

### 复制构造函数

复制构造函数原型：Class_name(const Class_name &)，当函数按值传递对象或函数返回对象时，即**生成对象副本**的时候都会调用复制构造函数，逐个复制**非静态**成员的值，即浅复制

复制构造函数构造的对象副本也会在失效的时候调用析构函数，这是一个**注意点**

在动态分配内存是，如果有调用复制构造函数按值传递对象，可能会导致两个对象的成员指向同一个地址，这时其中一个对象失效导致另一个对象存在**不确定性**

为解决这种不确定性，应该**显式**定义复制构造函数，深度复制，确保每一个对象都有自己的成员值

### 重载赋值运算符

与复制构造函数类似，赋值运算符的隐式实现也是浅复制，但也有一些不同之处

重载的赋值运算符需要做到：

- delete动态分配的内存
- 避免将对象赋给自身
- 返回一个指向调用对象的引用

在动态分配内存的类，使用默认的赋值运算符可能会导致错误的生成，所以需要重载运算符避免错误的发生

复制构造函数与重载的赋值运算符的**主要区别**在于，前者是创建了一个新的对象，而后者是更改原来的对象；因此，重载的赋值运算符会有一个delete释放内存的操作

### 完善动态内存下的类声明

关键字nullptr表示**空指针**，用法是将关键字赋值给变量

使用中括号表示法访问字符时，重载中括号运算符对于**常量与非常量**的字符要使用不同的重载函数，后者需要加const

可以将成员函数声明为静态的，此时**只能**通过类调用它，并且它只能使用静态数据成员

在返回值的选择上，如果可以返回对象或返回对象的引用，**首选**返回对象的引用；至于是否const，依情况而定

### 指向对象的指针

由于delete可与常规new运算符配合使用，**但不能**与定位new运算符配合使用，在释放存储在缓冲区的对象时，要显式调用析构函数，除此之外，释放的顺序要与创建在缓冲区的对象的顺序相反，最后释放缓冲区

**只有**构造函数可以使用**成员初始化列表**，初始化那些**只能**在被创建时初始化的变量，比如常量和引用；数据成员被初始化的顺序与它们出现在类声明中顺序相同，与初始化器中的排列顺序无关

可以先将目前未使用但也许会被隐式调用的函数声明为私有的，可以避免自动生成默认函数

队列是和栈一样的ADT，不过与栈的后进先出不同，队列是先进先出
