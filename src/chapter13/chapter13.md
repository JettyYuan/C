# chapter13

## 派生

使用**公有派生**，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问

**创建**派生类对象时，先调用基类的构造函数；而**释放**对象的顺序与创建对象的顺序相反，先调用派生类的析构函数

**基类指针**可以在不进行显式类型转换的情况下指向派生类对象；**基类引用**可以在不进行显式类型转换的情况下引用派生类对象

基类指针或引用**只能**用于调用基类方法；不可以将基类对象和地址赋给派生类引用和指针

基类引用定义的函数或指针参数可用于基类对象或派生类对象；形参为指向基类的指针的函数可以使用基类对象的地址或派生类对象的地址作为实参

C++有3种继承方式：公有继承、保护继承和私有继承

## 多态公有继承

- 在派生类中重新定义基类的方法
- 使用虚方法

使用关键字virtual的方法是虚方法，如果没有使用，程序将根据引用类型或指针类型选择方法；如果使用了，程序将根据引用或指针指向的对象的类型来选择方法

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的，关键字virtual**只**用于类声明的方法原型中

使用虚析构函数可以确保正确的析构函数序列被调用
