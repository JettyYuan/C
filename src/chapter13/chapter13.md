# chapter13

## 派生

使用**公有派生**，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问

**创建**派生类对象时，先调用基类的构造函数；而**释放**对象的顺序与创建对象的顺序相反，先调用派生类的析构函数

**基类指针**可以在不进行显式类型转换的情况下指向派生类对象；**基类引用**可以在不进行显式类型转换的情况下引用派生类对象

基类指针或引用**只能**用于调用基类方法；不可以将基类对象和地址赋给派生类引用和指针

基类引用定义的函数或指针参数可用于基类对象或派生类对象；形参为指向基类的指针的函数可以使用基类对象的地址或派生类对象的地址作为实参

C++有3种继承方式：公有继承、保护继承和私有继承

## 多态公有继承

- 在派生类中重新定义基类的方法
- 使用虚方法

使用关键字virtual的方法是虚方法，如果没有使用，程序将根据引用类型或指针类型选择方法；如果使用了，程序将根据引用或指针指向的对象的类型来选择方法

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的，关键字virtual**只**用于类声明的方法原型中

使用虚析构函数可以确保正确的析构函数序列被调用

## 联编

- 联编，将源代码中函数调用解释为执行特定的函数代码块
- 静态联编，在编译过程中进行联编
- 动态联编，在运行过程中进行联编

---

- 向上强制转换，将派生类引用或指针转换为基类引用或指针，隐式
- 向下强制转换，将基类指针或引用转换为派生类指针或引用，必须显式转换

编译器对**非虚方法**使用静态联编，对**虚方法**使用动态联编

虚函数注意事项

- 构造函数**不能**是虚函数
- 析构函数**应当**是虚函数，除非类不用做基类；如果给不是基类的类提供虚析构函数会降低效率
- 友元**不能**是虚函数
- 重新定义继承的方法并不是重载，如果重新定义派生类中的函数，无论参数列表是否相同，将会隐藏基类的**所有同名**方法
因此，如果重新定义继承的方法，应确保与基类的方法原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针
如果基类声明被重载了，则应在派生类中重新定义所有的基类版本，只定义一个版本会导致另外两个版本被隐藏，派生类对象无法使用

## protected

派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员

## 抽象基类

抽象基类必须至少包含一个纯虚函数，原型中的=0是虚函数称为纯虚函数，在类中可以不定义纯虚函数，但C++允许纯虚函数有定义

## 派生类的动态内存分配

如果派生类也使用动态内存分配，**必须**为派生类定义显式析构函数、复制构造函数和赋值运算符

派生类析构函数只需要管理自己额外创建的动态内存，复制构造函数需要在初始化成员列表中调用基类的复制构造函数，赋值运算符需要显式调用基类的赋值运算符
