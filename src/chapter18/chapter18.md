# chapter18

## 列表初始化等

可以使用列表初始化调用构造函数，**但如果**类有将模板std::initialize_list作为参数的构造函数，则**只有**该构造函数可以使用列表初始化，其他的构造函数不行

1.auto

2.decltype

3.返回类型后置

4.类型别名using=，与typedef作用类似但功能更强大

5.nullptr

6.智能指针，如unique_ptr、shared_ptr和weak_ptr

7.关键字noexcept，作用是指出函数不会引发指针

8.作用域内枚举，使用class或struct定义

9.类的改进(C++11)

- 显式转换运算符，explicit，用于类中函数的声明，避免隐式自动转换可能带来的问题
- 类内成员初始化，不能使用圆括号版本初始化

10.模板和STL的改进(C++11)

- 基于范围的for循环，可修改数组或容器内的值
- 新增STL容器
- 新增STL方法
- valarray可以使用STL的算法
- 尖括号，声明嵌套模板时，必须使用空格与尖括号分开

11.右值引用，&&

12.移动语义

对空指针使用delete []没有问题，不能让多个指针指向相同的数据

使用左值对象初始化对象时，将使用复制构造函数，而使用右值对象初始化对象时，将使用移动构造函数

std::move()可以确保操作是移动语义的，但前提是有移动语义的函数，比如移动赋值运算符

---

使用default标记类内特殊函数可是其生成默认版本

使用delete标记类内成员函数可禁用函数

派生类可以通过using语句继承基类的构造函数，但其只能初始化基类成员

使用override标记成员函数说明其是重写于基类的虚方法

使用final标记成员函数禁止其覆盖与派生类同名的函数，一般用于同名但参数列表不同的函数之间

## lambda函数

lambda表达式可以不表明返回值类型，但**仅限**于一条语句，如果有多条语句必须使用后置返回类型标明

可以创建一个auto类型的变量存储lambda表达式，这样可以像一般函数一样使用

lambda表达式还有一个特性就是在[]中加多个参数用来指定表达式捕获的变量，例如&是按引用访问动态变量，=是按值访问所有动态变量等

函数名、函数指针、函数对象或有名称的lambda表达式等都有一个由参数类型和返回参数类型构成的调用特征标

## 包装器

包装器可以使用调用特征标创建变量，将需要用到的函数等赋值给创建的变量，避免模板多次相同的实例化

比如function包装器，也可以只创建一个变量直接作为参数用于函数，但在使用时要把要用到的函数等作为包装器的参数

## 可变参数模板

元运算符，省略号，跟在typename后表示一个模板参数包，跟在T后面表示一个类型参数包

展开参数包时将省略号放在参数名的右侧，但如果要使用展开的参数包必须有效的使用递归

## 头文件

### utility

通用工具库的一部分

[utility](http://www.cppds.com/cpp/header/utility.html)
